rules_version = '2';

service cloud.firestore {

  match /databases/{database}/documents {



    // --- Helper Functions ---

    function isAuthenticated() {

      return request.auth != null;

    }



    function isOwner(userId) {

      return isAuthenticated() && request.auth.uid == userId;

    }



// Blocks collection

    match /blocks/{blockId} {

      // Users can create blocks for themselves

      allow create: if request.auth != null 

        && request.resource.data.blockerId == request.auth.uid;

      

      // Users can read their own blocks

      allow read: if request.auth != null 

        && resource.data.blockerId == request.auth.uid;

      

      // Users can delete their own blocks

      allow delete: if request.auth != null 

        && resource.data.blockerId == request.auth.uid;

      

      // No updates allowed (blocks are immutable)

      allow update: if false;

    }

    

    // Reports collection

    match /reports/{reportId} {

      // Users can create reports

      allow create: if request.auth != null 

        && request.resource.data.reporterId == request.auth.uid;

      

      // Only admins can read reports (or restrict as needed)

      // For now, users can read their own reports

      allow read: if request.auth != null 

        && resource.data.reporterId == request.auth.uid;

      

      // No updates or deletes for users

      allow update: if false;

      allow delete: if false;

    }

    

    // User subcollections for blocking

    match /users/{userId}/blocked_posts/{postId} {

      allow read, write: if request.auth != null 

        && request.auth.uid == userId;

    }

    

    match /users/{userId}/blocked_users_content/{blockedUserId} {

      allow read, write: if request.auth != null 

        && request.auth.uid == userId;

    }

    

    match /users/{userId}/blocked_users_messaging/{blockedUserId} {

      allow read, write: if request.auth != null 

        && request.auth.uid == userId;

    }

  



		//

		// FCM

		//

  match /fcm_tokens/{userId} {

    allow read: if isOwner(userId);

    allow write: if isOwner(userId);

  }



// ============================================================

// FEEDBACKS COLLECTION

// ============================================================

match /feedbacks/{feedbackId} {

  allow read: if false;  // No reads from users

  allow create: if isAuthenticated() && 

                  request.resource.data.userId == request.auth.uid;

  allow update: if false;  // No updates

  allow delete: if false;  // No deletes

}



    // ============================================================

    // USERS COLLECTION

    // ============================================================

    match /users/{userId} {

      allow read: if true;



      allow create: if isOwner(userId) &&

                      request.resource.data.keys()

                        .hasAll(['id', 'email', 'username', 'displayName', 'createdAt']);



      allow update: if (

              isOwner(userId) &&

              request.resource.data.id == resource.data.id &&

              request.resource.data.email == resource.data.email &&

              request.resource.data.username == resource.data.username &&

              request.resource.data.createdAt == resource.data.createdAt

            )

            ||

            (

              isAuthenticated() &&

              request.resource.data.diff(resource.data).changedKeys()

                .hasOnly(['followersCount', 'followingCount'])

            );



      allow delete: if false;

    }



    // ============================================================

    // ZAPS COLLECTION

    // ============================================================

    match /zaps/{zapId} {

      allow read: if isAuthenticated() &&

                     (!resource.data.keys().hasAny(['isDeleted']) ||

                      resource.data.isDeleted == false);



      allow create: if isAuthenticated() &&

                      request.resource.data.userId == request.auth.uid &&

                      request.resource.data.keys().hasAll(['id', 'userId', 'text', 'createdAt', 'isDeleted']) &&

                      request.resource.data.isDeleted == false;



      allow update: if isAuthenticated() &&

                     (isOwner(resource.data.userId) ||

                      request.resource.data.diff(resource.data).affectedKeys()

                        .hasOnly(['likedBy', 'rezapedBy', 'likesCount', 'rezapsCount', 'repliesCount', 'isDeleted']));



      allow delete: if false;

    }



    // ============================================================

    // SHORTS COLLECTION

    // ============================================================

    match /shorts/{shortId} {

      allow read: if isAuthenticated() &&

                     (!resource.data.keys().hasAny(['isDeleted']) ||

                      resource.data.isDeleted == false);



      allow create: if isAuthenticated() &&

                      request.resource.data.userId == request.auth.uid &&

                      request.resource.data.keys().hasAll(['id', 'userId', 'text', 'createdAt', 'isDeleted']) &&

                      request.resource.data.isDeleted == false;



      allow update: if isAuthenticated() &&

                      (isOwner(resource.data.userId) ||

                       request.resource.data.diff(resource.data).affectedKeys()

                         .hasOnly(['likedBy', 'rezapedBy', 'likesCount', 'rezapsCount', 'isDeleted']));



      allow delete: if false;

    }



    // ============================================================

    // MESSAGES

    // ============================================================

 match /messages/{messageId} {

  allow read: if isAuthenticated() &&

              request.auth.uid in resource.data.recipientsIds &&

              (!resource.data.keys().hasAny(['isDeleted']) ||

               resource.data.isDeleted == false);



  allow create: if isAuthenticated() &&

                request.resource.data.senderId == request.auth.uid &&

                request.resource.data.keys()

                  .hasAll([

                    'id',

                    'senderId',

                    'recipientsIds',  // ✅ Fixed: was 'recipientsId'

                    'conversationId',

                    'createdAt',

                    'isDeleted'

                  ]) &&

                request.resource.data.isDeleted == false &&

                request.auth.uid in request.resource.data.recipientsIds &&  // ✅ Fixed: was 'recipientsId'

                request.resource.data.recipientsIds is list &&

                request.resource.data.recipientsIds.size() > 0;



allow update: if isAuthenticated() &&

              (

                (

                  // Sender allowed to modify limited fields

                  request.auth.uid == resource.data.senderId &&

                  request.resource.data.diff(resource.data)

                    .affectedKeys()

                    .hasOnly(['isDeleted'])

                )

                ||

                (

                  // Any participant allowed to mark read / update media

                  request.auth.uid in resource.data.recipientsIds &&

                  // Check that only allowed fields are being changed

                  request.resource.data.diff(resource.data).affectedKeys()

                    .hasOnly(['isRead', 'isPending', 'mediaUrls', 'updatedAt']) &&

                  // Ensure critical fields are not being changed

                  request.resource.data.id == resource.data.id &&

                  request.resource.data.senderId == resource.data.senderId &&

                  request.resource.data.recipientsIds == resource.data.recipientsIds &&

                  request.resource.data.conversationId == resource.data.conversationId

                )

              );



  allow delete: if false;

}

    // ============================================================

    // CONVERSATIONS

    // ============================================================

    match /conversations/{conversationId} {

      allow read: if isAuthenticated() &&

                    request.auth.uid in resource.data.get('recipients', []);



      allow create: if isAuthenticated() &&

                      request.auth.uid in request.resource.data.get('recipients', []) &&

                      request.resource.data.keys().hasAll(['id', 'recipients', 'createdAt']);



      allow update: if isAuthenticated() &&

                      request.auth.uid in resource.data.get('recipients', []);



      allow delete: if false;

    }



    // ============================================================

    // NOTIFICATIONS

    // ============================================================

    match /notifications/{notificationId} {

      allow read: if isAuthenticated() &&

                    resource.data.userId == request.auth.uid;



      allow create: if isAuthenticated() &&

                      request.resource.data.userId != request.auth.uid &&

                      request.resource.data.keys()

                        .hasAll(['id', 'userId', 'fromUserId', 'type', 'createdAt']);



      allow update: if isAuthenticated() &&

                      resource.data.userId == request.auth.uid &&

                      request.resource.data.diff(resource.data).affectedKeys()

                        .hasOnly(['isRead']);



      allow delete: if false;

    }



    // ============================================================

    // STORIES

    // ============================================================

    match /stories/{storyId} {

      allow read: if isAuthenticated() &&

                    (

                      resource.data.visibility == 'public' ||

                      request.auth.uid in resource.data.get('visibleTo', []) ||

                      resource.data.userId == request.auth.uid

                    );



      allow create: if isAuthenticated() &&

                      request.resource.data.userId == request.auth.uid &&

                      request.resource.data.keys()

                        .hasAll(['userId', 'caption', 'mediaUrl', 'visibility', 'createdAt', 'visibleTo']);



      allow update: if isAuthenticated() && isOwner(resource.data.userId);



      allow delete: if isOwner(resource.data.userId);

    }



    // ============================================================

    // BOOKMARKS

    // ============================================================

    match /bookmarks/{bookmarkId} {

      allow read: if isAuthenticated();



      allow create: if isAuthenticated() &&

                      request.resource.data.userId == request.auth.uid &&

                      request.resource.data.keys().hasAll(['userId', 'zapId', 'createdAt']);



      allow delete: if isAuthenticated() &&

                      resource.data.userId == request.auth.uid;



      allow update: if false;

    }



    // ============================================================

    // COMMENTS

    // ============================================================

    match /comments/{commentId} {

      allow read: if isAuthenticated();



      allow create: if isAuthenticated() &&

                      request.resource.data.userId == request.auth.uid &&

                      request.resource.data.keys().hasAll(['id', 'userId', 'postId', 'text', 'createdAt']);



      allow update: if isAuthenticated() && isOwner(resource.data.userId);



      allow delete: if isAuthenticated() && isOwner(resource.data.userId);

    }



    // ============================================================

    // FOLLOWERS

    // ============================================================

    match /followers/{userId}/users/{followerId} {

      allow read: if isAuthenticated() &&

                    (

                      userId == request.auth.uid ||

                      get(/databases/$(database)/documents/following/$(request.auth.uid)/users/$(userId)).exists

                    );



      allow create: if isAuthenticated() &&

                      followerId == request.auth.uid &&

                      userId != request.auth.uid &&

                      request.resource.data.keys().hasAll(['createdAt']);



      allow delete: if isAuthenticated() && followerId == request.auth.uid;



      allow update: if false;

    }



    // ============================================================

    // FOLLOWING

    // ============================================================

    match /following/{userId}/users/{followingId} {

      allow read: if isAuthenticated() &&

                    (

                      userId == request.auth.uid ||

                      get(/databases/$(database)/documents/followers/$(request.auth.uid)/users/$(userId)).exists

                    );



      allow create: if isAuthenticated() &&

                      userId == request.auth.uid &&

                      followingId != request.auth.uid &&

                      request.resource.data.keys().hasAll(['createdAt']);



      allow delete: if isAuthenticated() &&

                      userId == request.auth.uid;



      allow update: if false;

    }



   // ============================================================

//  ANALYTICS COLLECTION (for stories, posts, etc.)

// ============================================================

match /analytics/{type}/{type2}/{itemId} {

  allow read: if isAuthenticated();



  allow create: if isAuthenticated() &&

                 request.resource.data.keys().hasOnly([

                   'views', 'likes', 'comments', 'shares', 'reposts', 'viewedBy'

                 ]);



  allow update: if isAuthenticated() &&

                 request.resource.data.diff(resource.data).changedKeys()

                   .hasOnly(['views', 'likes', 'comments', 'shares', 'reposts', 'viewedBy']);



  allow delete: if false;

}



// ============================================================

//  ANALYTICS → USERS TAG WEIGHTS & USER LIKING WEIGHTS

// ============================================================

match /analytics/users/users/{userId} {

  allow read: if isAuthenticated() && request.auth.uid == userId;



  allow update, create: if isAuthenticated() &&

                        request.auth.uid == userId &&

                        request.resource.data.keys().hasOnly(['tagsLiked', 'usersLiked']);



  allow delete: if false;

}



// ============================================================

//  USER INTERACTIONS COLLECTION

// ============================================================

match /user_interactions/{userId}/{category}/{itemId} {

  allow read: if isAuthenticated() && request.auth.uid == userId;



  allow create: if isAuthenticated() && request.auth.uid == userId;



  allow update: if isAuthenticated() && request.auth.uid == userId;



  allow delete: if false;

}

  // ============================================================

    //  CACHED RECOMMENDATIONS COLLECTION

    // ============================================================

    match /cached_recommendations/{userId} {

      // User can read their own cached recommendations

      allow read: if isAuthenticated() && request.auth.uid == userId;

      

      // Only cloud functions can write (via Admin SDK)

      // Clients cannot write directly

      allow create, update: if false;

      allow delete: if false;

    }

     // ============================================================

    //  CACHED RECOMMENDATIONS COLLECTION FOR STORIES

    // ============================================================

    match /cached_story_recommendations/{userId} {

      // User can read their own cached recommendations

      allow read: if isAuthenticated() && request.auth.uid == userId;

      

      // Only cloud functions can write (via Admin SDK)

      // Clients cannot write directly

      allow create, update: if false;

      allow delete: if false;

    }

     // ============================================================

    //  CACHED RECOMMENDATIONS COLLECTION FOR SHORTS

    // ============================================================

    match /cached_short_recommendations/{userId} {

      // User can read their own cached recommendations

      allow read: if isAuthenticated() && request.auth.uid == userId;

      

      // Only cloud functions can write (via Admin SDK)

      // Clients cannot write directly

      allow create, update: if false;

      allow delete: if false;

    }



    // ============================================================

    //  DAILY CURATED ZAPS COLLECTION

    // ============================================================

    match /daily_curated_zaps/{document} {

      // Anyone authenticated can read curated zaps

      allow read: if isAuthenticated();

      

      // Only cloud functions can write (via Admin SDK)

      // Clients cannot write directly

      allow create, update: if false;

      allow delete: if false;

    }

    

    // ============================================================

    //  DAILY CURATED SHORTS COLLECTION

    // ============================================================

    match /daily_curated_shorts/{document} {

      // Anyone authenticated can read curated zaps

      allow read: if isAuthenticated();

      

      // Only cloud functions can write (via Admin SDK)

      // Clients cannot write directly

      allow create, update: if false;

      allow delete: if false;

    }



  }

}

